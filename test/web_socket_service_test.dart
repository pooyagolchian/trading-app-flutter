import 'dart:convert';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:trading_app/core/services/websocket_service.dart';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
// RUN mock-test.sh before run flutter test
import 'web_socket_service_test.mocks.dart'; // This file will be generated by command - MOCK data

@GenerateMocks([WebSocketChannel, WebSocketSink])
void main() {
  late MockWebSocketChannel mockChannel;
  late MockWebSocketSink mockSink;
  late WebSocketService webSocketService;

  setUp(() async {
    await dotenv.load();
    mockChannel = MockWebSocketChannel();
    mockSink = MockWebSocketSink();
    when(mockChannel.sink).thenReturn(mockSink);
    when(mockSink.close(any, any)).thenAnswer((_) async => null);
    webSocketService = WebSocketService(channel: mockChannel);
  });

  test('should subscribe to a symbol', () {
    const symbol = 'BINANCE:BTCUSDT';
    when(mockSink.add(any)).thenReturn(null);
    webSocketService.subscribe(symbol);
    final expectedMessage =
        json.encode({'type': 'subscribe', 'symbol': symbol});
    verify(mockSink.add(expectedMessage)).called(1);
  });

  test('should unsubscribe from a symbol', () {
    const symbol = 'BINANCE:BTCUSDT';
    when(mockSink.add(any)).thenReturn(null);
    webSocketService.unsubscribe(symbol);
    final expectedMessage =
        json.encode({'type': 'unsubscribe', 'symbol': symbol});
    verify(mockSink.add(expectedMessage)).called(1);
  });
  test('should close the WebSocket connection on dispose', () {
    webSocketService.dispose();
    verify(mockSink.close(any, any)).called(1);
  });

  test('should throw an exception if API key is missing', () {
    dotenv.env['FINNHUB_API_KEY'] = '';
    expect(() => WebSocketService(channel: mockChannel), throwsException);
  });

  test('should log data received from WebSocket', () {
    const event = '{"type":"trade","data":[{"p":120.5,"s":"BINANCE:BTCUSDT"}]}';
    when(mockChannel.stream).thenAnswer((_) => Stream.value(event));

    webSocketService.priceStream.listen((data) {
      expect(data['type'], equals('trade'));
      expect(data['data'][0]['p'], equals(120.5));
      expect(data['data'][0]['s'], equals('BINANCE:BTCUSDT'));
    });

    verify(mockChannel.stream).called(1);
  });

  test('should handle WebSocket error', () {
    const errorMessage = 'WebSocket error occurred';
    when(mockChannel.stream).thenAnswer((_) => Stream.error(errorMessage));

    webSocketService.priceStream.listen(
      (_) {},
      onError: (error) {
        expect(error, equals(errorMessage));
      },
    );

    verify(mockChannel.stream).called(1);
  });
}
